# Read Demo
https://github.com/primodiumxyz/developer/tree/main/examples/ReadDemo

This demo introduced you to the basics of reading data from Primodium tables using the MUD World Extension system.

There are detailed line-by-line comments in the source code.

## Quickstart

### The demo includes four important files:

- System Contract: `src/ReadDemoSystem.sol`
- System Tests: `test/ReadDemoSystem.t.sol`
- Deployment Script: `scripts/RegisterReadDemoSystem.s.sol`
- Interaction Script: `scripts/ReadMainBaseLevel.s.sol`

### Actions

1. Change your active directory:
```bash 
cd examples/ReadDemo/packages/contracts
```
2. Install the necessary packages:
```bash
`pnpm i`
```
3. Build the project:
```bash
`pnpm build`
```
4. Test the project:
```bash
`forge test`
```
5. Do a dry-run of deployment:
```bash
`forge script script/RegisterReadDemoSystem.s.sol --fork-url https://primodium-sepolia.rpc.caldera.xyz/http`
```
6. Deploy the System:
```bash
`forge script script/RegisterReadDemoSystem.s.sol --fork-url https://primodium-sepolia.rpc.caldera.xyz/http --broadcast`
```
7. Use a script to interact with the system:
```bash
`forge script script/ReadMainBaseLevel.s.sol --fork-url https://primodium-sepolia.rpc.caldera.xyz/http --broadcast`
```

## Getting Started (Walkthrough)

It is assumed you have scanned the resources available here:

- https://mud.dev/guides/extending-a-world
- https://developer.primodium.com/world-extension/setup

There may be some differences due to some breaking changes in their latest release.

You shouldn't need it, but the chain config for the Primodium Testnet is:

- Chain ID: 10017
- RPC: https://primodium-sepolia.rpc.caldera.xyz/http
- Block Explorer: https://primodium-sepolia.explorer.caldera.xyz/
- Native Symbol and Currency Name: ETH

## MUD Versions

This tutorial was built against MUD version `2.0.1`. If needed, the command to update to the latest MUD version is:

```bash
pnpm mud set-version --mudVersion 2.0.1 && pnpm i && pnpm build
```

The world address for the extension developer testnet v0.11.x is `0x46c1e9dd144fcf5477a542d3152d28bc0cfba0b6`

The `WORLD_ADDRESS` and `BLOCK_NUMBER` are pre-configured in the `.env.example`. You should copy this to `.env`, and make any desired changes there. This guide was written before the world was deployed, so the `BLOCK_NUMBER` will need to be updated.

The `.gitignore` is already configured to not upload your `.env`, but it is always good practice to confirm the ignores in your `.gitignore` for yourself. Anything pushed to Git lives there forever and can be retrieved by anyone even if you delete it in later commits. Check twice (maybe 3 times), push once. NEVER push live private keys or .env files to Git.

It's a good idea to start by getting familiar with the MUD documentation here: https://mud.dev/guides/extending-a-world. There may be some differences due to some breaking changes in their latest release.  This Demo was built with MUD v2.0.1.

## Tables
MUD stores all data in `Table`s.  Some are core to MUD, some are specific to Primodium, and some can be specific to your Extension.  MUD automatically generates solidity libraries for tables that handle setters, getters, and decoding.

More information on Tables here: https://mud.dev/store/tables

## MUD Config
The code can be found in `packages/contracts/mud.config.ts`

Every plugin will need a mudConfig, which is stored in `mud.config.ts`. Plugins must exist in a `Namespace`. Multiple `Systems` can exist in a namespace.

Since this demo only deploys a system for reading data, we will not need any new `Tables`, but we will need to declare a `Namespace` and `System`.

```typescript
import { defineWorld } from "@latticexyz/world";

export default defineWorld({
  namespace: "PluginExamples",
  systems: {
    ReadDemoSystem: {
      name: "ReadDemoSystem",
      openAccess: true,
    },
  },
  tables: {},
});
```

The `Namespace` is where the `System` will live.  They can be up to 16 characters long, and every namespace must be unique. If you run into a collision, choose a different name.  The revert should say something like `World_ResourceAlreadyExists()` if there is a namespace collision.

More details on MUD Config can be found here: https://mud.dev/config

## Create the System
The commented code can be found in `packages/contracts/src/systems/ReadDemoSystem.sol`

The code should compile with `pnpm build`.

```typescript
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";

import { Home } from "../primodium/tables/Home.sol";
import { Level } from "../primodium/tables/Level.sol";


contract ReadDemoSystem is System {
  function readMainBaseLevel() public returns (uint32) {

    StoreSwitch.setStoreAddress(_world());

    bytes32 playerEntity = bytes32(uint256(uint160(_msgSender())));
    bytes32 asteroidEntity = Home.get(playerEntity);
    bytes32 baseEntity = Home.get(asteroidEntity);

    return uint32(Level.get(baseEntity));
  }
}
```
<details>
<summary>Explanation</summary>

`System` contracts are created in `packages/contracts/src/systems`. They are fairly standard smart contracts that only need to import the critical functionality from MUD or the `World` you are interacting with.

```typescript
import { System } from "@latticexyz/world/src/System.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
```
The contract itself is a `System` so we need to import that MUD library. We also need to tell the contract our `Store` target. `StoreSwitch` allows us to specify the `World` address where our target `Table`s reside. 

```typescript
import { Home } from "../primodium/tables/Home.sol";
import { Level } from "../primodium/tables/Level.sol";
```
We import the necessary `Table` libraries from the target `World`. These libraries are constructed by MUD scripts during `pnpm build`, and include the specific `tableId`s and `fieldLayout`s, with appropriate setters and getters. They handle the encoding and decoding of the underlying storage records for us.

These libraries are available in the source code at `packages/contracts/src/primodium`, and potentially in an npm package at a later date.

```typescript
contract ReadDemoSystem is System {
```
Make sure this matches what you specified in `mud.config.ts`

```typescript
StoreSwitch.setStoreAddress(_world());
```
`StoreSwitch` allows us to choose the data source for our extension.  `_world()` is inherited from `System`, and resolves to the world that called this system.  Since our systems will be registered to the Primodium world, this tells us to use the Primodium tables.

https://mud.dev/world/reference/world-context#_world

```typescript
bytes32 playerEntity = bytes32(uint256(uint160(_msgSender())));
```

Every player has an ID generated from their address for interacting with the world.  This is the raw form; usually we use a helper function like `addressToEntity()` to make this cleaner.

`_msgSender()` allows us to find the address of the player calling this system. `msg.sender` won't work since that will be the Primodium world address.

https://mud.dev/world/reference/world-context#_msgsender

```typescript
bytes32 asteroidEntity = Home.get(playerEntity);
bytes32 baseEntity = Home.get(asteroidEntity);
```
This can be a little confusing at first.  In Primodium, `Home.get` is dual purpose. Using it on a player ID returns their home asteroid ID. Using it on an asteroid ID returns the base building ID of that asteroid.  Combined, we get the building ID of the main base building.

Most tables are not multipurpose like this, but it is common to need to drill down through parent-child entity ID layers.

```typescript
return uint32(Level.get(baseEntity));
```
And we're done.  A simple call to the Level table to get the level of the main base for the player.
</details>

## Testing the World Extension
The commented code can be found in `packages/contracts/test/ReadDemoSystem.t.sol`

The test should execute by running `forge test` within the `packages/contracts/` folder. If you want to see additional details, you can run `forge test -vvvv` with 1-5 `v`s to increase verbosity. I generally recommend 4 or 5 for debug.

Before we deploy this system, we should run tests. We'll be using `forge test` in this example, to test against a live deployment. `pnpm mud test` is another option, that has some additional complexities, so we are not using it for now.

We've included three tests in this example, to highlight a couple different situations.

The test file can be intimidating, especially the imports.  Most of these are boilerplate for tests and scripts that interact with MUD worlds.

A detailed explanation of most of the imports can be found here: https://mud.dev/guides/extending-a-world#deploy-to-the-blockchain

We will highlight some specific additional details in the Explanation below.

```typescript
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { MudTest } from "@latticexyz/world/test/MudTest.t.sol";
import { console2 } from "forge-std/Test.sol";

import { WorldRegistrationSystem } from "@latticexyz/world/src/modules/init/implementations/WorldRegistrationSystem.sol";
import { System } from "@latticexyz/world/src/System.sol";

import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { WorldResourceIdLib } from "@latticexyz/world/src/WorldResourceId.sol";
import { RESOURCE_SYSTEM } from "@latticexyz/world/src/worldResourceTypes.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";

import { ReadDemoSystem } from "../src/systems/ReadDemoSystem.sol";

import { IWorld } from "../src/codegen/world/IWorld.sol";
import { IWorld as IPrimodiumWorld } from "../src/primodium/world/IWorld.sol";

contract ReadDemoTest is MudTest {

  address extensionDeployerAddress = vm.envAddress("ADDRESS_ALICE");
  address playerAddressActive = vm.envAddress("ADDRESS_PLAYER_ACTIVE");
  address playerAddressInactive = vm.envAddress("ADDRESS_PLAYER_INACTIVE");

  bytes14 PRIMODIUM_NAMESPACE = bytes14("Primodium");
  bytes14 namespace = bytes14("PluginExamples");
  bytes16 system = bytes16("ReadDemoSystem");

  function setUp() public override {
    super.setUp();

    worldAddress = vm.envAddress("WORLD_ADDRESS");
    StoreSwitch.setStoreAddress(worldAddress);

    vm.createSelectFork(vm.envString("PRIMODIUM_RPC_URL"), vm.envUint("BLOCK_NUMBER"));
    console2.log("\nForkLivePrimodium is running.");

    WorldRegistrationSystem world = WorldRegistrationSystem(worldAddress);

    ResourceId namespaceResource = WorldResourceIdLib.encodeNamespace(bytes14(namespace));
    ResourceId systemResource = WorldResourceIdLib.encode(RESOURCE_SYSTEM, namespace, system);

    vm.startPrank(extensionDeployerAddress);

    world.registerNamespace(namespaceResource);

    ReadDemoSystem readDemoSystem = new ReadDemoSystem();
    world.registerSystem(systemResource, readDemoSystem, true);

    world.registerFunctionSelector(systemResource, "readMainBaseLevel()");

    vm.stopPrank();
  }

  function test_ReadMainBaseLevel_Inactive() public {
    vm.startPrank(playerAddressInactive);

    uint32 baseLevel = IWorld(worldAddress).PluginExamples__readMainBaseLevel();

    vm.stopPrank();
    assertEq(baseLevel, 0, "The base level should be 0 for an Inactive player.");
  }

  function test_ReadMainBaseLevel_Active() public {
    vm.startPrank(playerAddressActive);

    uint32 baseLevel = IWorld(worldAddress).PluginExamples__readMainBaseLevel();

    vm.stopPrank();
    assertEq(baseLevel, 1, "The base level should be 1 for an Active player.");
  }

  function test_SpawnAndReadMainBaseLevel() public {
    vm.startPrank(playerAddressInactive);

    uint32 baseLevel = IWorld(worldAddress).PluginExamples__readMainBaseLevel();

    IPrimodiumWorld(worldAddress).Primodium__spawn();
    baseLevel = IWorld(worldAddress).PluginExamples__readMainBaseLevel();

    vm.stopPrank();
    assertEq(baseLevel, 1, "The base level should be 1 for a freshly spawned player.");
  }
}
```

<details>
<summary>Explanation</summary>

```typescript
import { ReadDemoSystem } from "../src/systems/ReadDemoSystem.sol";
```
We need to import our `System` to use it.

```typescript
import { IWorld } from "../src/codegen/world/IWorld.sol";
import { IWorld as IPrimodiumWorld } from "../src/primodium/world/IWorld.sol";
```
We need the import specific features and types to our World Extension. These are found in `../src/codegen/`.  We also need to specific features of Primodium world.

```typescript
contract ReadDemoTest is MudTest {
```
We will be using the `MudTest` library, which extends the standard forge `Test` with some additional supporting functionality.

```typescript
address extensionDeployerAddress = vm.envAddress("ADDRESS_ALICE");
address playerAddressActive = vm.envAddress("ADDRESS_PLAYER_ACTIVE");
address playerAddressInactive = vm.envAddress("ADDRESS_PLAYER_INACTIVE");
```
Foundry Cheatcodes allows us quick access to `.env` parameters using `vm.envAddress`, `vm.Uint`, etc.  https://book.getfoundry.sh/cheatcodes/external

```typescript
function setUp() public override {
  super.setUp();
```
We need some of the background setUp that occurs in MudTest.

```typescript
vm.createSelectFork(vm.envString("PRIMODIUM_RPC_URL"), vm.envUint("BLOCK_NUMBER"));
```
For these tests, we create a local temporary copy of the live Primodium blockchain, at a specific block number.  Changes to this blockchain are not sent back to the real one, so we can do thorough testing without danger of unintended consequences.

```typescript
WorldRegistrationSystem world = WorldRegistrationSystem(worldAddress);
```
This is our primary interface to Primodium world for the duration of the test.

```typescript
ResourceId namespaceResource = WorldResourceIdLib.encodeNamespace(bytes14(namespace));
ResourceId systemResource = WorldResourceIdLib.encode(RESOURCE_SYSTEM, namespace, system);
```
`ResourceId`s are type wrapped `bytes32`s. They are the primary type we use to access most game data.

`encodeNamespace()` and `encode()` handle the messy bitshifting into appropriate `ResourceId` formats for interfacing with `Table`s and `Systems`s.

```typescript
world.registerSystem(systemResource, readDemoSystem, true);
```
This line associates the derived `ResourceId` to a `System` address, and sets access permissions.  https://mud.dev/world/reference/world-external#registersystem

```typescript
world.registerFunctionSelector(systemResource, "readMainBaseLevel()");
```
The `System` may be registered, but we also need to tell the `World` what functions are provided by the `System`. This handles that. The function text is a function signature, and needs to include all the input parameters, e.g. `"transfer(address,uint256)"`.  No spaces.

</details>

## Deploying the World Extension